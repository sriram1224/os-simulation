import random

# Define disk size and block size
DISK_SIZE = 100
BLOCK_SIZE = 10

# Define file types and their respective sizes
FILE_TYPES = {
    'document': 5,
    'spreadsheet': 10,
    'image': 20
}


class File:
    def _init_(self, name, type, size):
        self.name = name
        self.type = type
        self.size = size


class FileSystem:
    def _init_(self, allocation_algorithm):
        self.disk = [None] * DISK_SIZE
        self.allocation_algorithm = allocation_algorithm
        self.files = []

    def allocate_blocks(self, size):
        # Use the chosen allocation algorithm to allocate blocks
        return self.allocation_algorithm(size, self.disk)

    def add_file(self, file):
        # Allocate blocks for the file
        blocks = self.allocate_blocks(file.size)

        # Add the file to the file system and mark the blocks as used
        if blocks:
            self.files.append(file)
            for block in blocks:
                self.disk[block] = file

    def delete_file(self, name):
        # Find the file with the given name and mark its blocks as unused
        for file in self.files:
            if file.name == name:
                for i in range(len(self.disk)):
                    if self.disk[i] == file:
                        self.disk[i] = None
                self.files.remove(file)
                break

    def rename_file(self, old_name, new_name):
        # Find the file with the given old name and rename it
        for file in self.files:
            if file.name == old_name:
                file.name = new_name
                break

    def move_file(self, name, new_size):
        # Find the file with the given name and move it to new blocks
        for file in self.files:
            if file.name == name:
                # Allocate new blocks for the file and mark the old blocks as unused
                new_blocks = self.allocate_blocks(new_size)
                old_blocks = []
                for i in range(len(self.disk)):
                    if self.disk[i] == file:
                        old_blocks.append(i)
                        self.disk[i] = None
                # If new blocks are available, move the file to the new blocks
                if new_blocks:
                    for i in range(len(new_blocks)):
                        self.disk[new_blocks[i]] = file
                        if i < len(old_blocks):
                            self.disk[old_blocks[i]] = None
                    file.size = new_size
                # If new blocks are not available, move the file back to the old blocks
                else:
                    for block in old_blocks:
                        self.disk[block] = file
                break

    def check_fragmentation(self):
        # Calculate the number of unused blocks and check for fragmentation
        unused_blocks = 0
        for block in self.disk:
            if not block:
                unused_blocks += 1
        fragmentation = unused_blocks / DISK_SIZE
        return fragmentation

    def check_wasted_space(self):
        # Calculate the number of unused blocks that are not adjacent to other unused blocks
        unused_blocks = []
        for i in range(len(self.disk)):
            if not self.disk[i]:
                unused_blocks.append(i)
        wasted_space = 0
        for i in range(len(unused_blocks)):
            if i == 0 or i == len(unused_blocks) - 1:
                wasted_space += 1
            elif unused_blocks[i] != unused_blocks[i - 1] + 1:
                wasted_space += 1
        return wasted_space


# Define first-fit allocation algorithm
def first_fit(size, disk):
    # Find the first block that is large enough to hold the file
    for i in range(len(disk)):
        if not disk[i]:
            blocks_needed = (size + BLOCK_SIZE - 1) // BLOCK_SIZE
            contiguous_blocks = 0
            for j in range(i, min(i + blocks_needed, len(disk))):
                if not disk[j]:
                    contiguous_blocks += 1
                else:
                    contiguous_blocks = 0
                if contiguous_blocks == blocks_needed:
                    return list(range(j - blocks_needed + 1, j + 1))
    # If no blocks are found, return an empty list
    return []

# create a FileSystem instance
fs = FileSystem(first_fit)

# take user input for file name, type, and size
name = input("Enter file name: ")
type = input("Enter file type (document, spreadsheet, or image): ")
size = int(input("Enter file size: "))

# create a File instance and add it to the file system
file = File(name, type, size)
fs.add_file(file)

